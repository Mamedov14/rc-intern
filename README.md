# Internship Red Collar

## Задание

Реализовать интеллектуальную систему, соответсвующую следующему описанию.

Интеллектуальная программа умеет с помощью наводящих вопросов угадывать животное, загаданное игроком. Для этого у нее
есть база знаний, состоящая из вопросов о свойствах животных и ответов на них. В начале работы база знаний состоит из
одного вопроса “живет на суше?” и двух ответов: да - кот и нет - кит. По ходу игры программа задает вопросы из своей
базы знаний и в конце концов либо угадывает животное, если у нее оно есть в базе знаний, либо ошибается, если загаданное
животное и имеющееся в базе знаний неотличимы по запрошенным свойствам. Во втором случае, программа спрашивает у игрока,
животное, которое он загадал, и свойство, которым оно отличается от имеющегося в базе. После этого программа обновляет
свою базу знаний и предлагает сыграть еще раз.

Пример диалога:

```
"Загадай животное, а я попробую угадать..."
"Это животное живет на суше? (да/нет)"
> да
"Это кот? (да/нет)"
> нет
"Какое животное ты загадал?"
> обезьяна
"Чем “обезьяна” отличается от “кот”?"
> ест бананы
```

После этого в базе знаний программы уже 2 вопроса и 3 животных.
Необходимо спроектировать структуру данных, наиболее эффективно отражающую базу знаний, и реализовать алгоритм игры,
задающий вопросы в соответствии с базой знаний, получающий ответы и обновляющий при необходимости базу знаний.

## Пояснение к алгоритму

1. `Node`: Этот класс представляет узел бинарного дерева, где каждый узел может содержать вопрос или животное. Узел
   имеет
   значение (текст вопроса или имя животного), ссылку на положительное поддерево и ссылку на отрицательное поддерево.
2. `BinaryTree`: Этот интерфейс определяет методы для навигации по бинарному дереву, такие как переход к следующему узлу
   и проверка наличия следующего различия.
3. `AnimalUtils`: Этот интерфейс определяет методы для получения различий и животных из узлов бинарного дерева, а также
   для сохранения новых животных с различиями.
4. `Resettable`: Этот интерфейс определяет метод drop(), который позволяет сбросить текущее состояние игры к начальному
   узлу.
5. `Repository`: Этот интерфейс объединяет функциональность `BinaryTree`, `AnimalUtils` и `Resettable`.

## Асимптотика алгоритма

Сложность алгоритма зависит от размера бинарного дерева, которое будет создано в процессе игры.
В худшем случае, если дерево достигнет максимальной глубины, время выполнения асимптотически `O(log N)`, где `N` -
количество узлов в дереве.

## Улучшения

+ Что касается алгоритма, кажется, что сделать быстрее чем за `O(log N)` невозможно.
+ С самого начала хотелось написать что-то типа Spring MVC приложения, для более дружелюбного использования.
+ Так же можно представить данную структуру в виде таблицы в БД, которая ссылалась бы сама на себя, тогда мы
  смогли бы хранить граф в реляционной базе и полностью поддерживать пополнение базы без потерь при перезапуске
  приложения.
+ Можно было бы в целом посмотреть под другим углом на задание и добавить подсказки, то есть, было бы неплохо если бы мы
  знали с какой буквы начинается слово, тогда можно было обойтись BST деревом, это кажется интересной темой для
  продолжения задачи.
+ Чтобы не заполнять базу руками, можно заоплнить `.csv` файл данными и сделать миграцию используя Liquibase.
